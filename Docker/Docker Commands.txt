1. docker ps --size --format "table {{.ID}}\t{{.Image}}\t{{.Names}}\t{{.Size}}"  

CONTAINER ID   IMAGE                     NAMES            SIZE  
cddae31c314f   acme/my-final-image:1.0   my_container_5   0B (virtual 7.75MB)  
939b3bf9e7ec   acme/my-final-image:1.0   my_container_4   0B (virtual 7.75MB)  
3ed3c1a10430   acme/my-final-image:1.0   my_container_3   5B (virtual 7.75MB)  
a5ff32e2b551   acme/my-final-image:1.0   my_container_2   5B (virtual 7.75MB)  
40ebdd763416   acme/my-final-image:1.0   my_container_1   5B (virtual 7.75MB)  

2. docker run -dit --name my_container_1 acme/my-final-image:1.0 bash \  

3. docker info  

4.  docker run -d --restart unless-stopped redis  
        docker update --restart unless-stopped redis  
        docker update --restart unless-stopped $(docker ps -q)  
  
Restart policies are different from the **--live-restore** flag of the dockerd command. Using **--live-restore** lets you to keep your containers running during a Docker upgrade, though networking and user input are interrupted.  
  
Use a restart policy
To configure the restart policy for a container, use the --restart flag when using the docker run command. The value of the --restart flag can be any of the following:  

Flag	                        Description  
no	                        Don't automatically restart the container. (Default)  
on-failure[:max-retries]    	Restart the container if it exits due to an error, which manifests as a non-zero exit code. Optionally, limit the number of times the Docker daemon                                        attempts to restart the container using the :max-retries option. The on-failure policy only prompts a restart if the container exits with a failure. It                                    doesn't restart the container if the daemon restarts.  
always	                        Always restart the container if it stops. If it's manually stopped, it is restart only when Docker daemon restarts or the container itself is manually                                     restarted. (See the second bullet listed in restart policy details)  
unless-stopped	                Similar to always, except that when the container is stopped (manually or otherwise), it isn't restarted even after Docker daemon restarts.  

## Create a Dockerfile that prints the numbers 1 to 5 and then exits. ##  

FROM busybox:latest  
COPY --chmod=755 <<"EOF" /start.sh  
echo "Starting..."  
for i in $(seq 1 5); do  
  echo "$i"  
  sleep 1  
done  
echo "Exiting..."  
exit 1  
EOF  
ENTRYPOINT /start.sh  
  
5. docker run -it ubuntu:24.04 /bin/bash
6. docker run -it -m 300M --memory-swap -1 ubuntu:24.04 /bin/bash     -- We set memory limit and disabled swap memory limit, this means the processes in the container can use 300M memory and as much swap memory as they need (if the host supports swap memory).
7. docker run -it -m 300M ubuntu:24.04 /bin/bash     --We set memory limit only, this means the processes in the container can use 300M memory and 300M swap memory, by default, the total virtual memory size (--memory-swap) will be set as double of memory, in this case, memory + swap would be 2*300M, so processes can use 300M swap memory as well.
8. docker run -it --cpuset-cpus="1,3" ubuntu:24.04 /bin/bash --docker run -it --cpuset-cpus="1,3" ubuntu:24.04 /bin/bash
9. docker run -it --cpuset-cpus="0-2" ubuntu:24.04 /bin/bash  -- This means processes in container can be executed on cpu 0, cpu 1 and cpu 2.
10. docker run --rm --group-add audio --group-add nogroup --group-add 777 busybox id   ## --group-add: Add additional groups to run as

uid=0(root) gid=0(root) groups=10(wheel),29(audio),99(nogroup),777
11.  docker run --name=test -d \
    --health-cmd='stat /etc/passwd || exit 1' \
    --health-interval=2s \
    busybox sleep 1d

12. sleep 2; docker inspect --format='{{.State.Health.Status}}' test
healthy
13. docker exec test rm /etc/passwd
14. sleep 2; docker inspect --format='{{json .State.Health}}' test

============================================================================================================================
docker run -d nginx
docker ps
docker logs -n 5 0246aa4d1448  <- container ID
docker run -a stdin -a stdout -i -t ubuntu /bin/bash      ##The --attach (or -a) flag tells docker run to bind to the container's STDIN, STDOUT or STDERR. This makes it possible to                                                                 manipulate the output and input as needed. You can specify to which of the three standard streams (STDIN, STDOUT, STDERR)
echo "test" | docker run -i -a stdin ubuntu cat -        ## The following example pipes data into a container and prints the container's ID by attaching only to the container's STDIN.
docker ps -q --filter ancestor=nginx:alpine

docker network create my-net
docker run -d --name web --network my-net nginx:alpine
docker run --rm -it --network my-net busybox

 docker run --foo busybox; echo $?   ## Exit code 125 indicates that the error is with Docker daemon itself., Exit code 126 indicates that the specified contained command can't be invoked. The container command in the following example is: /etc., Exit code 127 indicates that the contained command can't be found.

 docker run busybox /bin/sh -c 'exit 3'
 echo $?                                                ## Any exit code other than 125, 126, and 127 represent the exit code of the provided container command.
--------------------------------------------------------------------------------------------------------------------
NETWORKING

$ docker network create demo-network -d bridge
$ docker run -it --rm --name container1 --network demo-network busybox:latest
$ docker network connect demo-network container2
$ docker run -d --name nginx --network host nginx:latest
$ docker run -it --rm --network none busybox:latest
$ docker network disconnect demo-network container2   ##Remove network from container
$ docker network ls

NETWORK ID     NAME           DRIVER    SCOPE
44edcc537a6f   bridge         bridge    local
2cf9f8f370ad   demo-network   bridge    local
4d60b27f787a   host           host      local
288376a0a4f8   none           null      local

$ docker network rm demo-network
$ docker network prune  ## You can automatically delete all unused networks using the network prune command.

Example ---

version: "3"
services:
  app:
    image: php:7.2-apache
  mysql:
    image: mysql:8.0
    environment:
      MYSQL_ROOT_PASSWORD=changeme

$ docker compose up -d




