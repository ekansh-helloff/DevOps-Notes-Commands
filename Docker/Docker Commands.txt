1. docker ps --size --format "table {{.ID}}\t{{.Image}}\t{{.Names}}\t{{.Size}}"  

CONTAINER ID   IMAGE                     NAMES            SIZE  
cddae31c314f   acme/my-final-image:1.0   my_container_5   0B (virtual 7.75MB)  
939b3bf9e7ec   acme/my-final-image:1.0   my_container_4   0B (virtual 7.75MB)  
3ed3c1a10430   acme/my-final-image:1.0   my_container_3   5B (virtual 7.75MB)  
a5ff32e2b551   acme/my-final-image:1.0   my_container_2   5B (virtual 7.75MB)  
40ebdd763416   acme/my-final-image:1.0   my_container_1   5B (virtual 7.75MB)  

2. docker run -dit --name my_container_1 acme/my-final-image:1.0 bash \  
2.1     sudo systemctl status docker
3. docker info  

4.  docker run -d --restart unless-stopped redis  
        docker update --restart unless-stopped redis  
        docker update --restart unless-stopped $(docker ps -q)  
  
Restart policies are different from the **--live-restore** flag of the dockerd command. Using **--live-restore** lets you to keep your containers running during a Docker upgrade, though networking and user input are interrupted.  
  
Use a restart policy
To configure the restart policy for a container, use the --restart flag when using the docker run command. The value of the --restart flag can be any of the following:  

Flag	                        Description  
no	                        Don't automatically restart the container. (Default)  
on-failure[:max-retries]    	Restart the container if it exits due to an error, which manifests as a non-zero exit code. Optionally, limit the number of times the Docker daemon                                        attempts to restart the container using the :max-retries option. The on-failure policy only prompts a restart if the container exits with a failure. It                                    doesn't restart the container if the daemon restarts.  
always	                        Always restart the container if it stops. If it's manually stopped, it is restart only when Docker daemon restarts or the container itself is manually                                     restarted. (See the second bullet listed in restart policy details)  
unless-stopped	                Similar to always, except that when the container is stopped (manually or otherwise), it isn't restarted even after Docker daemon restarts.  

## Create a Dockerfile that prints the numbers 1 to 5 and then exits. ##  

FROM busybox:latest  
COPY --chmod=755 <<"EOF" /start.sh  
echo "Starting..."  
for i in $(seq 1 5); do  
  echo "$i"  
  sleep 1  
done  
echo "Exiting..."  
exit 1  
EOF  
ENTRYPOINT /start.sh  
  
5. docker run -it ubuntu:24.04 /bin/bash
6. docker run -it -m 300M --memory-swap -1 ubuntu:24.04 /bin/bash     -- We set memory limit and disabled swap memory limit, this means the processes in the container can use 300M memory and as much swap memory as they need (if the host supports swap memory).

7. docker run -it -m 300M ubuntu:24.04 /bin/bash     --We set memory limit only, this means the processes in the container can use 300M memory and 300M swap memory, by default, the total virtual memory size (--memory-swap) will be set as double of memory, in this case, memory + swap would be 2*300M, so processes can use 300M swap memory as well.

8. docker run -it --cpuset-cpus="1,3" ubuntu:24.04 /bin/bash
8.1   docker update --cpus=1 app              ## Apply CPUlimits

9. docker run -it --cpuset-cpus="0-2" ubuntu:24.04 /bin/bash  -- This means processes in container can be executed on cpu 0, cpu 1 and cpu 2.
10. docker run --rm --group-add audio --group-add nogroup --group-add 777 busybox id   ## --group-add: Add additional groups to run as

uid=0(root) gid=0(root) groups=10(wheel),29(audio),99(nogroup),777
11.  docker run --name=test -d \
    --health-cmd='stat /etc/passwd || exit 1' \
    --health-interval=2s \
    busybox sleep 1d

12. sleep 2; docker inspect --format='{{.State.Health.Status}}' test
healthy
13. docker exec test rm /etc/passwd
14. sleep 2; docker inspect --format='{{json .State.Health}}' test

docker exec -it container-name bash
echo "<h1>Hello from Docker Volume!</h1>" > /usr/share/nginx/html/index.html 
exit

============================================================================================================================
docker run -d nginx
docker ps
docker logs -n 5 0246aa4d1448  <- container ID
docker run -a stdin -a stdout -i -t ubuntu /bin/bash      ##The --attach (or -a) flag tells docker run to bind to the container's STDIN, STDOUT or STDERR. This makes it possible to                                                                 manipulate the output and input as needed. You can specify to which of the three standard streams (STDIN, STDOUT, STDERR)
echo "test" | docker run -i -a stdin ubuntu cat -        ## The following example pipes data into a container and prints the container's ID by attaching only to the container's STDIN.
docker ps -q --filter ancestor=nginx:alpine

docker network create my-net
docker run -d --name web --network my-net nginx:alpine
docker run --rm -it --network my-net busybox

 docker run --foo busybox; echo $?   ## Exit code 125 indicates that the error is with Docker daemon itself., Exit code 126 indicates that the specified contained command can't be invoked. The container command in the following example is: /etc., Exit code 127 indicates that the contained command can't be found.

 docker run busybox /bin/sh -c 'exit 3'
 echo $?                                                ## Any exit code other than 125, 126, and 127 represent the exit code of the provided container command.
--------------------------------------------------------------------------------------------------------------------
NETWORKING

$ docker network create demo-network -d bridge
$ docker run -it --rm --name container1 --network demo-network busybox:latest
$ docker network connect demo-network container2
$ docker run -d --name nginx --network host nginx:latest
$ docker run -it --rm --network none busybox:latest
$ docker network disconnect demo-network container2   ##Remove network from container
$ docker network ls

NETWORK ID     NAME           DRIVER    SCOPE
44edcc537a6f   bridge         bridge    local
2cf9f8f370ad   demo-network   bridge    local
4d60b27f787a   host           host      local
288376a0a4f8   none           null      local

$ docker network rm demo-network
$ docker network prune  ## You can automatically delete all unused networks using the network prune command.

Example ---

version: "3"
services:
  app:
    image: php:7.2-apache
  mysql:
    image: mysql:8.0
    environment:
      MYSQL_ROOT_PASSWORD=changeme

$ docker compose up -d

docker compose up -d           # Start services
docker compose down            # Stop and remove containers
docker compose down -v         # Remove containers + volumes
docker volume ls               # List all volumes
docker volume inspect db_data  # Inspect a specific volume
======================================================================================
docker volume create mydata
docker run -d -v mydata:/app/data nginx
docker run -d -v /home/user/website:/usr/share/nginx/html nginx
docker run -d  --name mynginx2  -p 8081:80  -v mydata:/usr/share/nginx/html  nginx
docker inspect container1
====================================================================================

docker run --mount type=bind,src=/logs,dst=/app/logs app:v1    #Instead of -v, I prefer --mount because it's explicit, supports bind/volume/tmpfs, and avoids ambiguous volume creation.
docker run --cap-drop=ALL --cap-add=NET_ADMIN vpn-proxy
docker exec -it --privileged                                         #Gives full root capabilities (rare but needed for debugging kernel-level issues).
docker update --cpus=2 --memory=1g app                        #Dynamically change CPU/memory limits without restart.
docker wait                                                        #Blocks until container exits â†’ helpful in CI scripts
docker network create --driver=bridge --subnet=10.10.0.0/24 \
--gateway=10.10.0.1 custom-net                    #I create custom networks with fixed subnets to isolate workloads, assign policies, and avoid IP conflicts in multi-stack environments. 

docker network connect backend app1                #Attach/detach container from multiple networks.
docker run --network=none                #Fully isolate a container (zero connectivity).
docker stats                                #Live CPU/memory/network/blkio monitoring.
docker run --cpuset-cpus="0,3" app                #Pin container to specific CPU cores.
docker run --memory-swappiness                        #Controls how aggressively the kernel swaps the container.
docker run --memory-reservation                      #Soft memory limit (QoS).
docker scan myapp:latest                                #cans images for CVEs.
docker run --read-only -v /tmp app                        Mount root filesystem as read-only:
docker run --user 1001:1001                        #Avoid root-in-container anti-pattern.
export DOCKER_CONTENT_TRUST=1                        #Signing images using Docker Content Trust.

docker volume create \
  --driver local \
  --opt type=tmpfs \
  --opt device=tmpfs \
  cache

docker inspect app --format '{{.NetworkSettings.IPAddress}}'
docker system prune -a --volumes    #Cleanup unused images/volumes.
docker history app:latest                        #docker image history
docker image prune --filter     #Cleanup dangling layers without deleting everything.
docker logs -f --tail 300 app
docker cp                #Copy files into/out of a running container â€” useful in emergencies.
docker events                #Listen to real-time Docker Engine events.
docker top                #See container-level processes



Scenario-Based Docker Q&A


"Your containers keep restarting in production. How do you diagnose?"

Answer

I first check restart reasons using:
docker ps -a --filter "status=exited"
and
docker logs <container>

Then I run:

docker inspect --format='{{.State.OOMKilled}}' <container>

to confirm if itâ€™s an OOM kill. If needed, I reproduce locally:
docker run --memory=500m --memory-swap=500m app

Finally, I set proper memory reservation, limits, healthchecks and fail-fast logging.


docker inspect returns all metadata about a container or image.
| Output  | Meaning                                                                |
| ------- | ---------------------------------------------------------------------- |
| `true`  | Container was killed by the kernel OOM killer (memory limit exceeded). |
| `false` | Container exited normally, not due to OOM.                             |

docker inspect returns all metadata about a container or image.

ğŸ”¥ docker inspect --format='{{.State.ExitCode}}' payment-service
I use docker inspect --format '{{.State.ExitCode}}' to quickly diagnose why a container stopped â€” especially useful for detecting OOM kills, segmentation faults, or lifecycle issues

Exit Code	Meaning
0	Clean graceful shutdown
1	Application error
137	Killed (SIGKILL) â€” usually OOM kill
143	Graceful SIGTERM (e.g., Kubernetes stop)
139	Segmentation fault
126/127	Command not found or permission issues

ğŸ”¥ docker inspect --format='{{.HostConfig.Memory}}' my-app
If output is: 0
â¡ï¸ It means no memory limit applied (dangerous for production). This command helps me verify whether the container has proper memory limits.
If memory = 0, the container can consume all system RAM and cause node crashes.

To confirm memory limits in production
To check if autoscaling policies are correct
To ensure developers didn't push an image with wrong resource configs

ğŸ”¥ docker inspect --format='{{json .Mounts}}' web-app | jq

This covers:

Bind mounts
Named volumes
Anonymous volumes
tmpfs mounts
Read-only mounts

You use this when:

Debugging volume misconfigurations
Verifying correct mount paths in CI/CD environments
Ensuring logs are mounted to external storage
Auditing what data is persistent vs ephemeral
Checking file-permission issues caused by incorrect bind mounts

ğŸ”¥ docker inspect --format='{{.NetworkSettings.IPAddress}}'

gives the containerâ€™s internal network IP. Itâ€™s extremely useful when debugging microservice connectivity issues, verifying DNS resolution, or inspecting network isolation.
For custom bridge networks, I use {{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}} to handle multi-network setups.â€

ğŸ”¥ docker inspect --format '{{.Config.Env}}' â†’ show only env vars
ğŸ”¥ docker inspect --format '{{json .Config.Labels}}' â†’ show labels
ğŸ”¥ docker inspect --format '{{.HostConfig.PortBindings}}' â†’ show port mapping

ğŸ”¥ğŸ”¥ How do you secure containers in production?â€

Answer:

Drop privileges
--cap-drop ALL

Run as non-root
--user 1001:1001

Immutable FS
--read-only

Use distroless or slim images

Scan using
docker scan <image>

Enable Docker Content Trust
DOCKER_CONTENT_TRUST=1

Encrypt secrets using Vaults.

ğŸ”¥ğŸ”¥ 
